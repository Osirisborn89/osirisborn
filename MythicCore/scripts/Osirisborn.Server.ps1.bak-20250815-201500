#requires -Version 7.0
$ErrorActionPreference = 'Stop'

# ---- Paths
$Root     = Join-Path $env:USERPROFILE 'Osirisborn\MythicCore'
$DataDir  = Join-Path $Root 'data'
$WWW      = Join-Path $Root 'www'
$Store    = Join-Path $DataDir 'store.plasma'
$Mirror   = Join-Path $Root 'www\mirror.json'
$Port     = 7777

# ---- Helpers: storage
function Read-Store {
  if (Test-Path $Store) {
    try { return (Get-Content $Store -Raw | ConvertFrom-Json -Depth 64) } catch { }
  }
  # default
  [pscustomobject]@{
    user = [pscustomobject]@{ xp=0; rank="Initiate"; alias="Osirisborn"; progressPct=0; streakCurrent=0; streakLongest=0 }
    missions = [pscustomobject]@{ catalog=@{}; completed=@() }
    meta = [pscustomobject]@{ xpLog=@() }
    settings = [pscustomobject]@{ dailyGoal = 300; notify=$true }
  }
}
function Write-Store($s) {
  New-Item -ItemType Directory -Force -Path $DataDir | Out-Null
  $json = $s | ConvertTo-Json -Depth 64
  Set-Content -Path $Store -Value $json -Encoding UTF8
  # mirror (small summary consumed by some views)
  $mir = [pscustomobject]@{
    user = [pscustomobject]@{
      xp=[int]$s.user.xp; rank=$s.user.rank; alias=$s.user.alias; progressPct=[int]$s.user.progressPct;
      streakCurrent = [int]($s.user.streakCurrent   ?? 0)
      streakLongest = [int]($s.user.streakLongest   ?? 0)
      badges        = [int](($s.meta.badges?.Count) ?? 0)
    }
    targets = [pscustomobject]@{
      dailyGoal = [int]($s.settings.dailyGoal ?? 300)
      xpToday   = 0; xpRemaining = [int]($s.settings.dailyGoal ?? 300); suggestions = @()
    }
    updated = (Get-Date).ToString("o")
  }
  Set-Content -Path $Mirror -Value ($mir | ConvertTo-Json -Depth 6) -Encoding UTF8
}

# ---- Rank thresholds
$Ranks = @(
"Initiate","Ghost","Signal Diver","Network Phantom","Redline Operative",
"Shadow Architect","Spectral Engineer","Elite","Voidbreaker","God Tier: Osirisborn"
)
$Threshold = @{
  "Initiate"=0; "Ghost"=200; "Signal Diver"=600; "Network Phantom"=1200; "Redline Operative"=2000;
  "Shadow Architect"=3000; "Spectral Engineer"=4500; "Elite"=6500; "Voidbreaker"=9000; "God Tier: Osirisborn"=12000
}
function Update-RankProgress([int]$xp,[string]$rank){
  $idx = [Math]::Max(0, $Ranks.IndexOf($rank))
  $curr = $Threshold[$Ranks[$idx]]
  $next = $Threshold[$Ranks[ [Math]::Min($idx+1,$Ranks.Count-1) ]]
  $span = [Math]::Max(1, $next-$curr)
  $pct  = [int][Math]::Clamp( 100*($xp-$curr)/$span, 0, 100 )
  [pscustomobject]@{ NextRank = $Ranks[ [Math]::Min($idx+1,$Ranks.Count-1) ]; ProgressPct=$pct }
}
function Add-XP([int]$delta,[string]$reason){
  $s = Read-Store
  $s.user.xp = [int]$s.user.xp + $delta
  # rank up
  foreach($r in $Ranks){ if ($s.user.xp -ge $Threshold[$r]) { $s.user.rank=$r } }
  $pg = Update-RankProgress -xp $s.user.xp -rank $s.user.rank
  $s.user.progressPct = $pg.ProgressPct
  # log
  if (-not $s.meta) { $s | Add-Member meta ([pscustomobject]@{}) -Force }
  if (-not $s.meta.xpLog){ $s.meta | Add-Member xpLog @() -Force }
  $entry = [pscustomobject]@{ at=(Get-Date).ToString("o"); delta=$delta; reason=$reason; total=[int]$s.user.xp; rank=$s.user.rank }
  $s.meta.xpLog = @($s.meta.xpLog + $entry)
  Write-Store $s
  return $s
}

# ---- HTTP
Add-Type -AssemblyName System.Net.HttpListener
$listener = [System.Net.HttpListener]::new()
$listener.Prefixes.Add("http://+:$Port/")
$listener.Start()
Write-Host "Osirisborn server running â†’ http://localhost:$Port/  (Ctrl+C to stop)"

while ($true) {
  $ctx   = $listener.GetContext()
  $req   = $ctx.Request
  $res   = $ctx.Response
  $path  = $req.Url.AbsolutePath
  $meth  = $req.HttpMethod

  try {
    # ---- Static: index.html
    if ($meth -eq 'GET' -and ($path -eq '/' -or $path -eq '/index.html')) {
      $html = Get-Content (Join-Path $WWW 'index.html') -Raw
      $bytes = [Text.Encoding]::UTF8.GetBytes($html)
      $res.ContentType = 'text/html; charset=utf-8'
      $res.OutputStream.Write($bytes,0,$bytes.Length); $res.Close(); continue
    }
    # ---- Static: client.js
    elseif ($meth -eq 'GET' -and $path -eq '/client.js') {
      $js = Get-Content (Join-Path $WWW 'client.js') -Raw
      $bytes = [Text.Encoding]::UTF8.GetBytes($js)
      $res.ContentType = 'application/javascript; charset=utf-8'
      $res.OutputStream.Write($bytes,0,$bytes.Length); $res.Close(); continue
    }
    # ---- Static: mirror.json (if present)
    elseif ($meth -eq 'GET' -and $path -eq '/mirror.json' -and (Test-Path $Mirror)) {
      $json = Get-Content $Mirror -Raw
      $bytes = [Text.Encoding]::UTF8.GetBytes($json)
      $res.ContentType = 'application/json; charset=utf-8'
      $res.OutputStream.Write($bytes,0,$bytes.Length); $res.Close(); continue
    }

    # ---- DIAG
    if ($meth -eq 'GET' -and $path -eq '/diag') {
      $diag = [pscustomobject]@{
        modulesPath = (Join-Path $Root 'scripts\modules')
        exists = [pscustomobject]@{
          store    = Test-Path $Store
          missions = $true
          xp       = $true
        }
        mode = 'inline'
        visible = @(
          [pscustomobject]@{ Name='(inline) storage'; ModuleName='(inline)' },
          [pscustomobject]@{ Name='(inline) missions'; ModuleName='(inline)' }
        )
      }
      $out = $diag | ConvertTo-Json -Depth 6
      $bytes = [Text.Encoding]::UTF8.GetBytes($out)
      $res.ContentType = 'application/json; charset=utf-8'
      $res.OutputStream.Write($bytes,0,$bytes.Length); $res.Close(); continue
    }

    # ---- XP series + summary
    if ($meth -eq 'GET' -and $path -match '^/xp\.json$') {
      $days = [int]($req.QueryString['days'] ?? '30')
      $s = Read-Store
      # build daily buckets from xpLog
      $from = (Get-Date).Date.AddDays(-($days-1))
      $buckets = @{}
      foreach($i in 0..($days-1)){ $buckets[$from.AddDays($i).ToString('yyyy-MM-dd')] = 0 }
      foreach($e in ($s.meta.xpLog ?? @())){
        try {
          $d = (Get-Date $e.at).ToString('yyyy-MM-dd')
          if ($buckets.ContainsKey($d)) { $buckets[$d] = [int]$buckets[$d] + [int]$e.delta }
        } catch {}
      }
      $series = @()
      $cum=0
      foreach($kv in $buckets.GetEnumerator() | Sort-Object Name){
        $cum += [int]$kv.Value
        $series += [pscustomobject]@{ date=$kv.Key; xp=[int]$kv.Value; cumulative=[int]$cum }
      }
      $pg = Update-RankProgress -xp ([int]$s.user.xp) -rank $s.user.rank
      $summary = [pscustomobject]@{
        xpToday     = [int]($buckets[(Get-Date).ToString('yyyy-MM-dd')] ?? 0)
        dailyGoal   = [int]($s.settings.dailyGoal ?? 300)
        remaining   = [int][Math]::Max(0, ($s.settings.dailyGoal ?? 300) - ([int]($buckets[(Get-Date).ToString('yyyy-MM-dd')] ?? 0)))
        rank        = $s.user.rank
        xp          = [int]$s.user.xp
        progressPct = [int]$pg.ProgressPct
      }
      $payload = [pscustomobject]@{ days=$days; series=$series; summary=$summary }
      $json = $payload | ConvertTo-Json -Depth 6
      $bytes = [Text.Encoding]::UTF8.GetBytes($json)
      $res.ContentType = 'application/json; charset=utf-8'
      $res.OutputStream.Write($bytes,0,$bytes.Length); $res.Close(); continue
    }

    # ---- Missions: list/add/complete
    if ($meth -eq 'GET' -and $path -eq '/api/missions') {
      $s = Read-Store
      $items = @()
      $cat = $s.missions.catalog
      if ($cat -isnot [hashtable]) { $cat = @{} }
      foreach($k in $cat.Keys){
        $m = $cat[$k]
        $done = ($s.missions.completed ?? @()) -contains $k
        $items += [pscustomobject]@{ id=$m.id; title=$m.title; xp=[int]$m.xp; status=($done ? 'Completed' : 'In Progress') }
      }
      $out = [pscustomobject]@{ items = $items }
      $json = $out | ConvertTo-Json -Depth 6
      $bytes = [Text.Encoding]::UTF8.GetBytes($json)
      $res.ContentType = 'application/json; charset=utf-8'
      $res.OutputStream.Write($bytes,0,$bytes.Length); $res.Close(); continue
    }
    if ($meth -eq 'POST' -and $path -eq '/api/mission/add') {
      $body = (New-Object IO.StreamReader($req.InputStream,$req.ContentEncoding)).ReadToEnd()
      $p = $null; try { $p = $body | ConvertFrom-Json } catch {}
      if (-not $p.id) { throw "Missing id" }
      $s = Read-Store
      if ($s.missions.catalog -isnot [hashtable]) { $s.missions.catalog = @{} }
      $s.missions.catalog[$p.id] = [pscustomobject]@{ id=$p.id; title=($p.title ?? 'New Mission'); xp=[int]($p.xp ?? 0) }
      Write-Store $s
      $json = '{"ok":true}'
      $bytes = [Text.Encoding]::UTF8.GetBytes($json)
      $res.ContentType = 'application/json; charset=utf-8'
      $res.OutputStream.Write($bytes,0,$bytes.Length); $res.Close(); continue
    }
    if ($meth -eq 'POST' -and $path -eq '/api/mission/complete') {
      $body = (New-Object IO.StreamReader($req.InputStream,$req.ContentEncoding)).ReadToEnd()
      $p = $null; try { $p = $body | ConvertFrom-Json } catch {}
      if (-not $p.id) { throw "Missing id" }
      $s = Read-Store
      $m = $s.missions.catalog[$p.id]
      if (-not $m) { throw "Mission not found: $($p.id)" }
      if (-not $s.missions.completed) { $s.missions.completed = @() }
      if (($s.missions.completed) -contains $p.id) {
        $json='{"ok":true,"already":true}'
      } else {
        $s.missions.completed = @($s.missions.completed + $p.id)
        Write-Store (Add-XP -delta ([int]$m.xp) -reason "Mission: $($m.title)")
        $json='{"ok":true}'
      }
      $bytes = [Text.Encoding]::UTF8.GetBytes($json)
      $res.ContentType = 'application/json; charset=utf-8'
      $res.OutputStream.Write($bytes,0,$bytes.Length); $res.Close(); continue
    }

    # ---- Backup (create timestamped copy of store.plasma)
    if ($meth -eq 'POST' -and $path -eq '/api/backup') {
      New-Item -ItemType Directory -Force -Path $DataDir | Out-Null
      $ts = (Get-Date).ToString('yyyyMMdd-HHmmss')
      $dest = Join-Path $DataDir ("store.{0}.json" -f $ts)
      if (Test-Path $Store) { Copy-Item $Store $dest -Force } else { Set-Content -Path $dest -Value '{}' -Encoding UTF8 }
      $json = @{ ok=$true; file=$dest } | ConvertTo-Json
      $bytes = [Text.Encoding]::UTF8.GetBytes($json)
      $res.ContentType = 'application/json; charset=utf-8'
      $res.OutputStream.Write($bytes,0,$bytes.Length); $res.Close(); continue
    }

    # ---- Restore (from 'latest' or a path)
    if ($meth -eq 'POST' -and $path -eq '/api/restore') {
      $body = (New-Object IO.StreamReader($req.InputStream,$req.ContentEncoding)).ReadToEnd()
      $p = $null; try { $p = $body | ConvertFrom-Json } catch {}
      $file = "$($p.file)"
      if (-not $file) { throw "Missing 'file' property" }
      if ($file -eq 'latest') {
        $pick = Get-ChildItem -Path $DataDir -Filter 'store.*.json' | Sort-Object LastWriteTime -Descending | Select-Object -First 1
        if (-not $pick) { throw "No backups found in $DataDir" }
        Copy-Item $pick.FullName $Store -Force
        $out = @{ ok=$true; file=$pick.FullName }
      } else {
        if (-not (Test-Path $file)) { throw "Backup not found: $file" }
        Copy-Item $file $Store -Force
        $out = @{ ok=$true; file=$file }
      }
      # refresh mirror after restore
      $s = Read-Store; Write-Store $s
      $json = $out | ConvertTo-Json
      $bytes = [Text.Encoding]::UTF8.GetBytes($json)
      $res.ContentType = 'application/json; charset=utf-8'
      $res.OutputStream.Write($bytes,0,$bytes.Length); $res.Close(); continue
    }

    # ---- Fallback 404
    $res.StatusCode = 404
    $msg = @{ error = "Not found: $path" } | ConvertTo-Json
    $bytes = [Text.Encoding]::UTF8.GetBytes($msg)
    $res.ContentType = 'application/json; charset=utf-8'
    $res.OutputStream.Write($bytes,0,$bytes.Length); $res.Close()
  }
  catch {
    $res.StatusCode = 500
    $err = @{ error = $_.Exception.Message } | ConvertTo-Json
    $bytes = [Text.Encoding]::UTF8.GetBytes($err)
    $res.ContentType = 'application/json; charset=utf-8'
    $res.OutputStream.Write($bytes,0,$bytes.Length); $res.Close()
  }
}
